import{_ as a,o as i,c as e,a as h}from"./app-5c461d69.js";const r={},l=h('<h1 id="加密那些事儿" tabindex="-1"><a class="header-anchor" href="#加密那些事儿" aria-hidden="true">#</a> 加密那些事儿</h1><h2 id="加密和签名区别" tabindex="-1"><a class="header-anchor" href="#加密和签名区别" aria-hidden="true">#</a> 加密和签名区别</h2><h3 id="目标" tabindex="-1"><a class="header-anchor" href="#目标" aria-hidden="true">#</a> 目标</h3><ul><li>加密：主要目标是保护数据的机密性，确保只有授权的人或实体能够访问和解读加密的信息。</li><li>签名：主要目标是验证数据的完整性和真实性，确保数据未被篡改，并且可以确认数据的发送方。</li></ul><h3 id="操作对象" tabindex="-1"><a class="header-anchor" href="#操作对象" aria-hidden="true">#</a> 操作对象</h3><ul><li>加密：涉及加密和解密操作，使用密钥将原始数据转换为不可读的形式，然后使用相应的密钥进行解密还原。</li><li>签名：涉及签名和验证操作，使用私钥对数据进行签名，然后使用公钥来验证签名。</li></ul><h3 id="密钥用途" tabindex="-1"><a class="header-anchor" href="#密钥用途" aria-hidden="true">#</a> 密钥用途</h3><ul><li>加密：使用密钥来隐藏或转换数据，确保只有授权的用户能够还原和访问原始数据。</li><li>签名：使用密钥来生成和验证数字签名，以确保数据的完整性和真实性。</li></ul><h3 id="数据处理" tabindex="-1"><a class="header-anchor" href="#数据处理" aria-hidden="true">#</a> 数据处理</h3><ul><li>加密：对数据进行转换，以确保数据在传输或存储中不易被理解。</li><li>签名：对数据进行数字签名，以确保数据未被篡改，并验证数据的来源。</li></ul><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><ul><li>加密：通常应用于保护数据的机密性，例如保护通信中的敏感信息、存储中的文件、或在云环境中传输的数据。</li><li>签名：通常应用于验证数据的完整性和认证数据来源，例如数字证书、软件发布、数据传输的身份认证等场景。</li></ul><h3 id="密钥数量" tabindex="-1"><a class="header-anchor" href="#密钥数量" aria-hidden="true">#</a> 密钥数量：</h3><ul><li>加密：可能使用对称密钥或非对称密钥，具体取决于加密算法和使用情境。</li><li>签名：使用非对称密钥，包括私钥用于签名，公钥用于验证签名。</li></ul><h3 id="性能" tabindex="-1"><a class="header-anchor" href="#性能" aria-hidden="true">#</a> 性能：</h3><ul><li>加密：通常较快，尤其是对称加密，适用于大量数据的加密和解密。</li><li>签名：通常较慢，因为非对称加密相对复杂，适用于相对小量的关键操作。</li></ul><h2 id="对称加密和非对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密和非对称加密" aria-hidden="true">#</a> 对称加密和非对称加密</h2><h3 id="密钥数量-1" tabindex="-1"><a class="header-anchor" href="#密钥数量-1" aria-hidden="true">#</a> 密钥数量</h3><ul><li>对称加密：使用相同的密钥进行加密和解密。发送方和接收方必须共享同一个密钥。因此，对称加密使用的密钥是单一的。</li><li>非对称加密：使用一对密钥，包括公钥和私钥。公钥用于加密，私钥用于解密；或私钥用于签名，公钥用于验证签名。因此，非对称加密使用的密钥是成对的。</li></ul><h3 id="密钥分发" tabindex="-1"><a class="header-anchor" href="#密钥分发" aria-hidden="true">#</a> 密钥分发</h3><ul><li>对称加密：密钥的分发相对较复杂，因为发送方和接收方需要在通信之前安全地共享相同的密钥。这可能涉及到使用其他手段（例如物理传递、安全通道等）。</li><li>非对称加密：公钥可以公开分发，而私钥必须保持机密。这样，任何人都可以使用公钥加密信息，但只有私钥持有者能够解密。</li></ul><h3 id="加密-解密速度" tabindex="-1"><a class="header-anchor" href="#加密-解密速度" aria-hidden="true">#</a> 加密/解密速度</h3><ul><li>对称加密：通常较快，因为相同的密钥用于加密和解密操作，且算法相对简单。</li><li>非对称加密：通常较慢，因为不同的密钥用于加密和解密，且非对称算法相对复杂。</li></ul><h3 id="计算资源" tabindex="-1"><a class="header-anchor" href="#计算资源" aria-hidden="true">#</a> 计算资源</h3><ul><li>对称加密：需要较少的计算资源，适用于大量数据的加密和解密。</li><li>非对称加密：需要更多的计算资源，适用于相对小量的关键操作，例如密钥交换、数字签名等。</li></ul><h3 id="安全性" tabindex="-1"><a class="header-anchor" href="#安全性" aria-hidden="true">#</a> 安全性</h3><ul><li>对称加密：如果密钥安全地共享，通常是安全的。但密钥分发和管理可能成为挑战。</li><li>非对称加密：提供更好的安全性，因为公钥可以公开分发，而私钥保持私密。非对称加密常用于保护对称密钥的安全分发。</li></ul><p>在实际应用中，通常会将对称加密和非对称加密结合使用，以兼顾效率和安全性的需求。例如，使用非对称加密进行密钥协商和数字签名，而使用对称加密来加密实际的数据传输。这种组合称为混合加密。</p><h2 id="签名" tabindex="-1"><a class="header-anchor" href="#签名" aria-hidden="true">#</a> 签名</h2><p>数字签名是一种用于验证数据完整性和认证数据来源的加密技术。它通过使用私钥对数据进行签名，然后使用相应的公钥来验证签名，确保数据未被篡改并且是由合法的发送方生成的。</p><h3 id="密钥生成" tabindex="-1"><a class="header-anchor" href="#密钥生成" aria-hidden="true">#</a> 密钥生成</h3><ul><li>生成密钥对：发送方生成一对非对称密钥，包括私钥（用于签名）和公钥（用于验证签名）。</li></ul><h3 id="数据签名" tabindex="-1"><a class="header-anchor" href="#数据签名" aria-hidden="true">#</a> 数据签名</h3><ul><li>选择待签名数据：发送方选择要发送的数据，通常是消息或文件。</li><li>使用私钥签名：发送方使用私钥对待签名数据进行签名。签名算法会产生一个唯一的数字摘要，即签名。</li><li>生成数字签名：签名与原始数据一起发送，形成数字签名。</li></ul><h3 id="数据传输" tabindex="-1"><a class="header-anchor" href="#数据传输" aria-hidden="true">#</a> 数据传输</h3><ul><li>发送数据和签名：发送方将原始数据和数字签名一起发送给接收方。</li></ul><h3 id="数据验证" tabindex="-1"><a class="header-anchor" href="#数据验证" aria-hidden="true">#</a> 数据验证</h3><ul><li>接收数据和签名：接收方接收原始数据和数字签名。</li><li>使用公钥验证签名：接收方使用发送方的公钥对数字签名进行验证。这涉及使用相同的哈希算法重新计算数据的摘要，并与数字签名进行比较。</li><li>验证结果：如果重新计算的摘要与数字签名中的摘要匹配，验证成功，表示数据未被篡改且是由合法发送方生成的。</li></ul><h3 id="结果处理" tabindex="-1"><a class="header-anchor" href="#结果处理" aria-hidden="true">#</a> 结果处理</h3><ul><li>认证和完整性： 验证数字签名后，接收方可以信任数据的完整性，确信数据未被篡改，并且可以认证数据的发送方，即签名的私钥持有者。</li></ul><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h3><ul><li>私钥安全性：发送方的私钥必须保持机密，以防止第三方恶意使用私钥生成伪造的数字签名。</li><li>公钥分发：公钥通常可以被广泛分发，因为它用于验证签名，但是必须确保公钥的完整性，以防止公钥被替换为伪造的公钥。</li></ul><p>数字签名常用于安全通信、数据完整性验证、身份认证等场景，确保数据在传输过程中的安全性和可信度。</p><h2 id="我们的实现" tabindex="-1"><a class="header-anchor" href="#我们的实现" aria-hidden="true">#</a> 我们的实现</h2><h3 id="法规相关要求" tabindex="-1"><a class="header-anchor" href="#法规相关要求" aria-hidden="true">#</a> 法规相关要求</h3><p>针对固件大包进行签名。</p><h3 id="安全考虑" tabindex="-1"><a class="header-anchor" href="#安全考虑" aria-hidden="true">#</a> 安全考虑</h3><p>针对swu文件使用本身支持的算法，进行对称加密</p><h3 id="飞控的保护" tabindex="-1"><a class="header-anchor" href="#飞控的保护" aria-hidden="true">#</a> 飞控的保护</h3><p>使用飞控预置的算法 进行签名</p>',50),d=[l];function n(t,c){return i(),e("div",null,d)}const s=a(r,[["render",n],["__file","croptyo.html.vue"]]);export{s as default};
